// The "race to empty" bug implemented in Rholang. As described in
// http://vessenes.com/more-ethereum-attacks-race-to-empty-is-the-real-deal/

type ID = Ch

data Action = Withdraw ID
            | Send (Int, ID)

struct User {
  balance : Int,
  action  : Ch Action
}

contract TokenBankContr( users : ID => User, getBalance : Ch (ID, Ch Int), deposit : Ch ID ) = {
  select {
    case (user, rtn) <- getBalance => {
        match users[user] with
          Just (balance, _) => { rtn!(balance) }
          Nothing           => { rtn!(0) }
        
        | TokenBank( users, getBalance, deposit )
    }

    case user <- deposit => {
        users.insertsWith!( (+) , user, _.balance, msg.value ) |
        TokenBank( users, getBalance, deposit )
    } 

    case user <- users.keys; Withdraw to <- users[user].action;
      if to.send(users[user].balance) => { // We want to make sure that we are able to send the tokens.
        users.inserts!(user, _.balance, 0) |
        TokenBank( users, getBalance, deposit )
    }

    case user <- users.keys; Send (amount,receiver) <- users[user].action;
      if amount <= users[user].balance => {
        atomic {
          users.insertsWith!( (-) , user, _.balance, amount ) |
          users.insertsWith!( (+) , receiver, _.balance, amount ) |
        } |
        TokenBank( users', getBalance, deposit )
    }
  }
}

//////////////////////////////////////////////////////////////////////////////////////////

struct TokenBank {
  getBalance : Ch (ID, Ch Int),
  deposit    : Ch ID,
  priv       : Ch Action
}

contract MaliciousOwner( tokenBank : TokenBank, id : ID ) = {
  new id in
  
  tokenBank.priv!(Withdraw id) |

  for( !id.receive ) { // Banged for stream semantics. id.receive will receive a message
                       // every time someone sends the native token to the name id,
                       // and the listening process receives the included tokens.
    tokenBank.priv!(Withdraw id)
  }
}