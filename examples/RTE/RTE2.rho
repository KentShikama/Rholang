// The "race to empty" bug implemented in Rholang. As described in
// http://vessenes.com/more-ethereum-attacks-race-to-empty-is-the-real-deal/

type ID = Ch

data Action = Withdraw ID
            | Send (Int, ID)

struct User {
  balance : Int,
  action  : Ch Action
}

contract TokenBankContr( users : ID => User, getBalance : Ch (ID, Ch Int), deposit : Ch ID ) = {
  for( (user,rtn) <- !getBalance ) { // Channel name banged, for stream semantics (i.e. persistent continuation, ephemeral data)
      match users.get(user) with
        Just (balance, _) => { rtn!(balance) }
        Nothing           => { rtn!(0) }
  } |

  for( user <- !deposit ) {
      users.insertsWith!( (+) , user, _.balance, msg.value )
  } |

  for( user <- users.keys; Withdraw to <- !users[user].action;
    if to.send(users[user].balance) ) { // We want to make sure that we are able to send the tokens.
      users.inserts!(user, _.balance, 0)
  } |

  for( user <- users.keys; Send (amount,receiver) <- !users[user].action;
    if amount <= users[user].balance ) {
      atomic {
        users.insertsWith!( (-) , user, _.balance, amount ) |
        users.insertsWith!( (+) , receiver, _.balance, amount )
      }
    }
  }
}

//////////////////////////////////////////////////////////////////////////////////////////

struct TokenBank {
  getBalance : Ch (ID, Ch Int),
  deposit    : Ch ID,
  priv       : Ch Action
}

contract MaliciousOwner( tokenBank : TokenBank, id : ID ) = {
  new id in
  
  tokenBank.priv!(Withdraw id) |

  for( !id.receive ) { // id.receive will receive a message every time someone sends
                       // the native token to the name id, and the listening process
                       // receives the included tokens.
    tokenBank.priv!(Withdraw id)
  }
}