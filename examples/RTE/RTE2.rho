// The "race to empty" bug implemented in Rholang. As described in
// http://vessenes.com/more-ethereum-attacks-race-to-empty-is-the-real-deal/

type ID = Ch

data Action = Withdraw ID
            | Send (Int, ID)

struct User {
  balance : Int,
  action  : Ch Action
}

contract TokenBank( users : ID => User, getBalance : Ch (ID, Ch Int), deposit : Ch ID ) = {
  for( (user,rtn) <- !getBalance ) {
      match users.get(user) with
        Just (balance, _) => { rtn!(balance) }
        Nothing           => { rtn!(0) }
  } |

  for( user <- !deposit ) {
      users.insertWith!( (+) , user, _.balance, msg.value )
  } |

  for( user <- users.keys; Withdraw to <- !users[user].action;
    if to.send(users[user].balance) ) { // We want to make sure that we are able to send the tokens.
      users.inserts!(user, _.balance, 0)
  }

  for( user <- users.keys; Send (amount,receiver) <- !users[user].action;
    if amount <= users[user].balance ) {
      users.insertWith!( (-) , user, _.balance, amount ) |
      users.insertWith!( (+) , receiver, _.balance, amount )
    }
  }
}

//////////////////////////////////////////////////////////////////////////////////////////

struct TokenBank {
  getBalance : Ch (ID, Ch Int),
  deposit    : Ch ID,
  priv       : Ch Action
}

contract MaliciousOwner( tokenBank : TokenBank, id : ID ) = {
  new id in
  
  tokenBank.priv!(Withdraw id) |

  for( !id.receive ) { // Banged for stream semantics. id.receive will receive a message
                       // every time someone sends the native token to the name id,
                       // and the listening process receives the included tokens.
    tokenBank.priv!(Withdraw id)
  }
}