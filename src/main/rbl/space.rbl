;; -*- mode: Lisp;-*- 
;; Filename:    space.rbl 
;; Authors:     luciusmeredith                                                    
;; Creation:    Thu Feb 23 18:57:26 2017 
;; Copyright:   See site license
;; Description: Basic Linda pattern
;; ------------------------------------------------------------------------

;;; TODO: Add tag for whether persistent
(add '**wildcard** #niv) ;; TODO: Add wildcard token in Rosette implementation and swap out #niv

(defOprn append)
(defPure Tuple (append item) (reverse [item & (reverse (self))]))

(defOprn string-length<)
(defOprn string-length>=)
(defPure String (string-length< other) (< (string-length (self)) (string-length other)))
(defPure String (string-length>= other) (not (string-length< (self) other)))

;;; Deletes element at position i in Tuple
(defOprn delete-i)
(defPure Tuple (delete-i p)
	(concat (prim-sub-object (self) 0 p)
		(prim-sub-object (self) (fx+ p 1)
				 (fx- (prim-size (self)) (fx+ p 1)))))

(defOprn replace-i)
(defPure Tuple (replace-i p item)
	(concat
	    (prim-sub-object (self) 0 p)
	    [item]
		(prim-sub-object (self) (fx+ p 1)
				 (fx- (prim-size (self)) (fx+ p 1)))))

(defOprn symbol-list-concat)
(defPure Tuple (symbol-list-concat) (->symbol (fold (self) (proc [e acc k] (k (string-concat acc (->string e)))) "")))

(defOprn flatten)
(defPure Tuple (flatten) (fold (self) (proc [e acc k] (k (tuple-concat e acc))) []))

(defOprn twoZip)
(defPure Tuple (twoZip) (fold (self) (proc [[x y] acc k] (let [[[xs ys] acc]] (k [[x & xs] [y & ys]]))) [[] []]))

(defOprn length)
(defPure Tuple (length) (count (self) (proc [x] #t)))

(defOprn tbl-unique-append)
(defPure RblTable (tbl-unique-append key value)
    (let [[current_value (tbl-get (self) key)]]
        (if (= current_value #absent)
            (tbl-add (self) key [value])
            (if (type? current_value Tuple)
                (tbl-add (self) key (remove-duplicates (append current_value value)))
                (RuntimeError (self) "Value " current_value " at key " key " not a Tuple")
            )
        )
    )
)

(defOprn consume)
(defOprn produce)
(defOprn unify?)
(defOprn match?)
(defOprn production?)

(defActor NameSpace (slots& chart (new RblTable) channel_lookup_table (new RblTable) unification_ptrn_lookup_table (new RblTable))
    ;;; TODO: We currently do not support prologue style unification (bidirectional) pattern matching
    ;;; Potential implementation: (if (type? ptrn candidate) (seq (update) ((proc [ptrn] ptrn) candidate)) (seq (update) #niv)) )
    (pure (unify? ptrn candidate) #t)
    (pure (match? ptrn candidate) (if (= ptrn **wildcard**) #t (type? ptrn candidate)))
    ;;; storedValue is the tuple [data continuation]
    (pure (production? storedValue) (not (null? (head storedValue))))
)

(defOprn tuplespace-tbl-get-or-create)
(defPure RblTable (tuplespace-tbl-get-or-create channel)
    (let [[subspace (tbl-get (self) channel)]]
        (if (absent? subspace)
            (seq
                (tbl-add (self) channel (new RblTable))
                (tbl-get (self) channel)
            )
            subspace
        )
    )
)

(defRMethod NameSpace (consume ctxt & location)
    ;;; by making this a reflective method - RMethod - we gain access to the awaiting continuation
    ;;; bound to the formal parameter ctxt
(let* [
    [[channels unification_ptrns product_ptrns] location]
        ;;; the channel and the pattern of incoming messages to look for are destructured and bound
    [channels_concatenated (symbol-list-concat channels)]
    [unification_ptrns_concatenated (symbol-list-concat unification_ptrns)]
    [expanded_channel_groups
        (seq
            (map channels (proc [i channel] (tbl-unique-append channel_lookup_table channel channel)))
            (map channels (proc [i channel] (sort (tbl-get channel_lookup_table channel) string-length< string-length>=)))
        )
    ]
    [subspace_groups
        (map expanded_channel_groups (proc [i expanded_channel_group]
            (map expanded_channel_group (proc [j expanded_channel] (tuplespace-tbl-get-or-create chart expanded_channel)))))]
        ;;; the incoming messages associated with the channel are collected in a subtable (subspace)
        ;;; in this sense we can see that the semantic framework supports a compositional
        ;;; topic/subtopic/subsubtopic/â€¦ structuring technique that unifies message passing
        ;;; with content delivery primitives
        ;;; the channel name becomes the topic, and the pattern structure becomes
        ;;; the subtopic tree
        ;;; this also unifies with the URL view of resource access
    [subspace_groups_keys (map subspace_groups (proc [i subspace_group]
        (map subspace_group (proc [j subspace] (names subspace)))))]
    [candidates
        (map subspace_groups_keys (proc [i subspace_group_keys]
            (map subspace_group_keys (proc [j subspace_keys]
                (let*
                    [
                        [[extractions misses]
                            (fold subspace_keys
                                (proc [subspace_key acc k]
                                    (let [[[hits misses] acc]
                                        [binding (any (tbl-get unification_ptrn_lookup_table subspace_key) (proc [subspace_key_component] (unify? NameSpace (tuple-safe-nth unification_ptrns i) subspace_key_component)))]]
                                (if (niv? binding)
                                    (k [hits [subspace_key & misses]])
                                    (k [[[subspace_key binding] & hits] misses])))) [[] []])]
                            ;;; note that this is generic in the unify? and miss? predicates
                            ;;; matching could be unification (as it is in SpecialK) or it could be
                            ;;; a number of other special purpose protocols
                            ;;; the price for this genericity is performance
                            ;;; there is decent research showing that there are hashing disciplines
                            ;;; that could provide a better than reasonable approximation of unification

                            ;;; Returns [[[[[[channel_key binding] hits...] misses] another channel key ...]
                            ;;; another expanded channel ...] another expanded channel group ...]
                            ;;; TODO: Should return a list of bindings not #t or #f

                        [[data_group continuation_group]
                            (fold extractions
                                (proc [[unification_ptrn binding] acc k]
                                    (let* [[[data_group continuation_group] acc]
                                            [stored_value (tbl-get (tuple-safe-nth (tuple-safe-nth subspace_groups i) j) unification_ptrn)]
                                            [[data_struct continuations_struct] stored_value]]
                                    (if (production? NameSpace stored_value)
                                        (k [[[[unification_ptrn binding] data_struct] & data_group] continuation_group])
                                        (k [data_group [[unification_ptrn continuations_struct] & continuation_group]])))) [[] []])]
                            ;;; this divides the hits into those matches that are data and
                            ;;; those matches that are continuations
                            ;;; and the rest of the code sends data to the awaiting continuation
                            ;;; and appends the continuation to those matches that are currently
                            ;;; data starved
                            ;;; this is a much more fine-grained view of excluded middle

                            ;;; Returns [[[ [[[channel_key binding] data] [channel_key continuations]]
                            ;;; another channel key ...] another expanded channel ...] another expanded channel group ...]
                    ]
                    (let
                        [
                            [production_results
                                (map data_group (proc [m [[unification_ptrn binding] data_struct]]
                                    (map data_struct (proc [n product]
                                        (if (match? NameSpace (tuple-safe-nth product_ptrns i) product)
                                            [
                                                [(tuple-safe-nth channels i) (tuple-safe-nth (tuple-safe-nth subspace_groups i) j)]
                                                [(tuple-safe-nth unification_ptrns i) [unification_ptrn binding]]
                                                ["product" (tuple-safe-nth product_ptrns i) [n product]]
                                            ]
                                        )))))
                            ]
                            [consummation_results
                                (map continuation_group (proc [m [unification_ptrn continuations_struct]]
                                    (map continuations_struct (proc [n [product_ptrns_struct ctxt]]
                                        (map product_ptrns_struct (proc [o [product_ptrn product]]
                                            (if (match? NameSpace (tuple-safe-nth product_ptrns i) product)
                                                [
                                                    [(tuple-safe-nth channels i) (tuple-safe-nth (tuple-safe-nth subspace_groups i) j)]
                                                    [(tuple-safe-nth unification_ptrns i) [unification_ptrn binding]]
                                                    ["continuation" (tuple-safe-nth product_ptrns i) [n o product]]
                                                ]
                                            )))))))
                            ]
                        ]
                        (tuple-concat (flatten production_results) (flatten (flatten consummation_results)))
                    )
                )
                ))))]
                            ;;; continuations struct
                            ;;; [ [ [product_ptrn product] [product_ptrn #absent] ...] ctxt]

    ;;; Value function
    ;;; Input: [[[(c1,p) (u,u) (pp, p)],[(c1,p) (u,u) (pp, p)],...],[[(c2,p) (u,u) (pp, p)],...],...]
    ;;; Output: [[(c1,p) (u,u) (pp, p)],[(c2,p) (u,u) (pp, p)]]
    ;;; Since the channels are ordered by length, taking the head will always take the singletons first and then longer lists.
    ;;; The ordering makes it so that products will be taken first before "stealing" products from awaiting consumings.
    [reductions
        (let
            [[prefiltered_reductions (map candidates (proc [i channel_struct_group] (head (flatten channel_struct_group))))]]
            (if (any prefiltered_reductions (proc [channel] (null? channel))) [] prefiltered_reductions)
        )
    ]

    ;;; For each channel returned from value function, return the product and consume/delete it
    ;;; TODO: Return bindings and ptrn so they can be returned with ctxt-rtn
    [bindings_and_products
        (map reductions (proc [i channel]
            (let [[[[_ subspace] [_ [unification_ptrn binding]] [type _ product_info]] channel]]
                (if (= type "product")
                    (let*
                        [
                            [[data_struct continuations_struct] (tbl-get subspace unification_ptrn)]
                            [[n product] product_info]
                            [updated_data_struct (delete-i data_struct n)]
                        ]
                        (seq
                            (tbl-add subspace unification_ptrn [updated_data_struct continuations_struct])
                            [binding product]
                        )
                    )
                    ;;; (= type "continuation")
                    (let*
                        [
                            [[data_struct continuations_struct] (tbl-get subspace unification_ptrn)]
                            [[n o product] product_info]
                            [[product_ptrns_struct ctxt] (tuple-safe-nth continuations_struct n)]
                            [[product_ptrn _] (tuple-safe-nth product_ptrns_struct o)]
                            [updated_product_ptrns_struct (replace-i product_ptrns_struct o [product_ptrn #absent])]
                            [updated_continuations_struct (replace-i continuations_struct n [updated_product_ptrns_struct ctxt])]
                        ]
                        (seq
                            (tbl-add subspace unification_ptrn [data_struct updated_continuations_struct])
                            [binding product]
                        )
                    )))))]]

    (seq
        (if (null? bindings_and_products)
            ;;; If continuation was not consumed by a matching product (value function returned none), store it and suspend
            (seq
                (print "DEBUG: Waiting for data")
                (let*
                    [
                        [subspace (tuplespace-tbl-get-or-create chart channels_concatenated)]
                        [stored_value (tbl-get subspace unification_ptrns_concatenated)]
                        [new_product_ptrns_struct (map product_ptrns (proc [i product_ptrn] [product_ptrn #absent]))]
                    ]
                    (seq
                        (map channels (proc [i channel] (tbl-unique-append channel_lookup_table channel channels_concatenated)))
                        (tbl-add unification_ptrn_lookup_table unification_ptrns_concatenated unification_ptrns)
                        (if (= #absent stored_value)
                            (tbl-add subspace unification_ptrns_concatenated [[] [[new_product_ptrns_struct ctxt]]])
                            (let [[[data_struct continuations_struct] stored_value]]
                                (tbl-add subspace unification_ptrns_concatenated [data_struct (append continuations_struct [new_product_ptrns_struct ctxt])])))))
                (update!)
            )
            (seq
                (update!)
                (ctxt-rtn ctxt (twoZip bindings_and_products)))))))

;;; This code is perfectly dual to the consumer code and so all the comments
;;; there apply in the corresponding code sites

;;; Get list of potential channels to fill
;;; Get their subspaces
;;; For each subspace, see if unification_ptrn matches a key
;;; For matching keys, fetch data_group and continuation_group
;;; See if continuation_group has potential fill

;;; Value function:
;;; Input: All potential consumes that can be filled
;;; Output: The consume to fill or none

;;; If none, just store
;;; Else fill consume

;;; If continuation is fully filled, then send and remove consumed continuation_struct from continuation_group

(defRMethod NameSpace (produce ctxt & production)
(let* [[[channel unification_ptrn product] production]
    [expanded_channels
        (seq
            (tbl-unique-append channel_lookup_table channel channel)
            (tbl-get channel_lookup_table channel)
        )
    ]
    [subspaces (map expanded_channels (proc [i channel] (tuplespace-tbl-get-or-create chart channel)))]
    [subspace_group_keys (map subspaces (proc [i subspace] (names subspace)))]
    [candidates
        (map subspace_group_keys (proc [i subspace_keys]
            (let*
            [
                [[extractions remainder]
                    (fold subspace_keys
                        (proc [subspace_key acc k]
                            (let [[[hits misses] acc]
                                [binding (unify? NameSpace unification_ptrn subspace_key)]]
                            (if (niv? binding)
                                (k [hits [subspace_key & misses]])
                                (k [[[subspace_key binding] & hits] misses]))
                            )
                        ) [[] []])]
                [[data_group continuation_group]
                    (fold extractions
                        (proc [[unification_ptrn binding] acc k]
                            (let* [[[data_group continuation_group] acc]
                                    [stored_value (tbl-get (tuple-safe-nth subspaces i) unification_ptrn)]
                                    [[data_struct continuation_struct] stored_value]]
                            (if (production? NameSpace stored_value)
                                (k [[] continuation_group])
                                (k [data_group [[[unification_ptrn binding] continuation_struct] & continuation_group]])))) [[] []])
                ]
            ]
            (map continuation_group (proc [m [[unification_ptrn binding] continuations_struct]]
                (map continuations_struct (proc [n [product_ptrns_struct ctxt]]
                    (map product_ptrns_struct (proc [o [product_ptrn stored_product]]
                        (if (match? NameSpace product_ptrn product)
                            [
                                [channel (tuple-safe-nth subspaces i)]
                                [unification_ptrn unification_ptrn]
                                [product [n o product_ptrn]]
                            ]
                        ))))))))))]
    ;;; Value function
    ;;; Input: [[(c1,p) (u,u) (pp, p)],[(c2,p) (u,u) (pp, p)],...]
    ;;; Output: [(c1,p) (u,u) (pp, p)]
    ;;; Since the channels are ordered by length, taking the head will always take the singletons first and then longer lists.
    [reduction (head (flatten (flatten (flatten candidates))))] ;;; TODO: Refactor to (flattenN candidates 3) or (apply 3 flatten candidates)
    ]
    (seq
        (if (null? reduction)
            ;;; If product was not consumed by a matching continuation above, store it directly
            (let*
                [
                    [subspace (tuplespace-tbl-get-or-create chart channel)]
                    [stored_value (tbl-get subspace unification_ptrn)]
                ]
                (seq
                (tbl-add unification_ptrn_lookup_table (->symbol unification_ptrn) [unification_ptrn])
                (if (= #absent stored_value)
                    (tbl-add subspace unification_ptrn [[product] []])
                    (let [[[data_struct continuation_struct] (tbl-get subspace unification_ptrn)]]
                        (tbl-add subspace unification_ptrn [(append data_struct product) continuation_struct])))))

            ;;; If product was consumed, fill consume
            (let*
                [
                    [[[_ subspace] [_ unification_ptrn] [type product_info]] reduction]
                    [[data_struct continuations_struct] (tbl-get subspace unification_ptrn)]
                    [[n o product_ptrn] product_info]
                    [[product_ptrns_struct ctxt] (tuple-safe-nth continuations_struct n)]
                    [updated_product_ptrns_struct (replace-i product_ptrns_struct o [product_ptrn product])] ;;; TODO: Eventually store binding
                ]
                ;;; If filled, send ctxt-rtn
                (if (all updated_product_ptrns_struct (proc [[product_ptrn product]] (not (= product #absent))))
                    (seq
                        ;;; TODO: Replace dummy bindings
                        (send ctxt-rtn ctxt [(newN Tuple (length updated_product_ptrns_struct) #t) (map updated_product_ptrns_struct (proc [j [product_ptrn product]] product))])
                        (let [[updated_continuations_struct (delete-i continuations_struct n)]]
                            (tbl-add subspace unification_ptrn [data_struct updated_continuations_struct])
                        )
                    )
                    (let [[updated_continuations_struct (replace-i continuations_struct n [updated_product_ptrns_struct ctxt])]]
                        (tbl-add subspace unification_ptrn [data_struct updated_continuations_struct])
                    )
                )
            )
        )
        (update!)
        (ctxt-rtn ctxt product)
    )))
